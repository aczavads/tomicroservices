package br.pucrio.inf.les.opus.tomicroservices.analysis.dynamic;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import br.pucrio.inf.les.opus.tomicroservices.graph.Edge;
import br.pucrio.inf.les.opus.tomicroservices.graph.Graph;
import br.pucrio.inf.les.opus.tomicroservices.graph.Vertex;

/**
 * The analyzer of the output generated by injected code in the system under analyze
 * 
 * Schema to the analyze is the following (per line): "Class:name#Method:name#SizeOf:number#Deep:number" (can change the order)
 * 
 * @author Luiz Carvalho <lmcarvalho@inf.puc-rio.br>
 * 
 **/
public class DynamicLogAnalyzer {
	
	private List<String> generalFunctionalitiesToAllCases = new ArrayList<String>();
	private Map<String, String> generalClassPatternToFunctionality = new HashMap<String, String>();
	private List<String> functionalitiesToAllCases = new ArrayList<String>();
	private Map<String, String> classPatternToFunctionalityToAllCases = new HashMap<String, String>();
	
	private DeepToFunctionalities enableFunctionatiles;
	
	private final String startClass = "_star_t_";
	private final String startMethod = "_star_t_";
	
	private Map<String, String> analyzeLine(String line) {
		String[] classMethodSizeOfAndDeep = line.split("#");
		Map<String, String> result = new HashMap<String, String>();
		final int typeIndex = 0;
		final int valueIndex = 1;
		for (String typeAndValue: classMethodSizeOfAndDeep) {
			String type = typeAndValue.split(":")[typeIndex];
			String value = typeAndValue.split(":")[valueIndex];
			result.put(type, value);
		}
		return result;
	}
	
	private boolean verifyValues(Map<String, String> classMethodSizeOfAndDeep) {
		try {
			Long.parseLong(classMethodSizeOfAndDeep.get("SizeOf"));
			Long.parseLong(classMethodSizeOfAndDeep.get("Deep"));
		} catch (Exception e) {
			return false;
		}
		String threadName = classMethodSizeOfAndDeep.get("Thread");
		//if (!threadName.contains("Grizzly-worker")) {
		if (!threadName.contains("main")) {
			return false;
		}
		final int elementSize = 5;
		return classMethodSizeOfAndDeep.containsKey("Class") && classMethodSizeOfAndDeep.containsKey("Method") &&
				classMethodSizeOfAndDeep.containsKey("SizeOf") && classMethodSizeOfAndDeep.containsKey("Deep") &&
				classMethodSizeOfAndDeep.containsKey("Thread")
				&& classMethodSizeOfAndDeep.size() == elementSize;
	}
	
	/**
	 * Analyse the schema: SF:Feature1<ClassA, ClassB>#Feature2#...#FeatureN
	 * @param line line
	 * @return true if update functionalities, otherwise return false.
	 */
	private boolean analyseFunctionalitiesLine(String line, Map<String, String> classPatternToFunctionality, 
			List<String> functionalitiesToAllCases) {
		if (line.startsWith("SF:")) {
			line = line.replace("SF:", "");
			String functionalities[] = line.split("#");
			for (String func: functionalities) {
				if (func.contains("<")) {
					final int funcIndex = 0;
					final int patternsIndex = 1;
					String[] funcAndPatterns = func.split("<");
					String functionalityName = funcAndPatterns[funcIndex];
					funcAndPatterns[patternsIndex] = funcAndPatterns[patternsIndex].replace(">", "");
					String[] patterns = funcAndPatterns[patternsIndex].split(",");
					for (String pattern: patterns) {
						classPatternToFunctionality.put(pattern, functionalityName);
					}
				} else {
					if (func.length() > 0) {
						functionalitiesToAllCases.add(func);
					}
				}
			}
			return true;
		}
		return false;
	}
	
	private List<String> getFunctionalities(String absoluteName) {
		List<String> result = new ArrayList<String>();
		addPatterns(absoluteName, result, this.classPatternToFunctionalityToAllCases);
		addPatterns(absoluteName, result, this.generalClassPatternToFunctionality);
		return result;
	}

	private void addPatterns(String absoluteName, List<String> result, Map<String, String> mPattern) {
		Set<String> keys = mPattern.keySet();
		for (String key: keys) {
			if (absoluteName.startsWith(key)) {
				result.add(mPattern.get(key));
			}
			//if (absoluteName.matches(key)) {
			//	result.add(mPattern.get(key));
			//}
		}
		return;
	}
	
	private Map<String, String> nextLine(BufferedReader reader) throws IOException {
		String line = reader.readLine();
		long count = 0L;
		while (line != null) {
			++count;
			Map<String, String> result;
			if (analyseFunctionalitiesLine(line, this.classPatternToFunctionalityToAllCases, 
					this.functionalitiesToAllCases)) {
				this.enableFunctionatiles = new DeepToFunctionalities();
				result = new HashMap<String, String>();
				result.put("Class", this.startClass);
				result.put("Method", this.startMethod);
				return result;
				//line = reader.readLine();
				//continue;
			}
			result = analyzeLine(line);
			if (verifyValues(result)) {
				return result;
			} else {
				//System.err.println("Line out of standard: " + line + " in line " + count);
			}
			line = reader.readLine();
		}
		return null;
	}
	
	private Vertex generateVertex(String name, long deep) {
		List<String> funcs = getFunctionalities(name);
		if (!funcs.isEmpty()) {
			this.enableFunctionatiles.addFunctionalitites(deep, funcs);
		} else {
			funcs = this.enableFunctionatiles.getFunctionalities(deep);
			if (funcs == null) {
				funcs = new ArrayList<String>();
				funcs.addAll(this.generalFunctionalitiesToAllCases);
				funcs.addAll(this.functionalitiesToAllCases);
				this.enableFunctionatiles.addFunctionalitites(deep, funcs);
			}
		}
		return new Vertex(name, funcs);
	}
	
	private void extractGeneralFunctionalities(File generalFunctionalities) {
		if (generalFunctionalities == null) return;
		try (BufferedReader reader = new BufferedReader(
				new FileReader(generalFunctionalities))) {
			String line = reader.readLine();
			while (line != null) {
				analyseFunctionalitiesLine(line, this.generalClassPatternToFunctionality, 
						this.generalFunctionalitiesToAllCases);
				line = reader.readLine();
			}
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public void analyze(File log, Graph graph, File generalFunctionalities) {
		this.enableFunctionatiles = new DeepToFunctionalities();
		extractGeneralFunctionalities(generalFunctionalities);
		try (BufferedReader reader = new BufferedReader(
				new FileReader(log))) {
			String previousClass = "", previousMethod = "";
			Map<String, String> classMethodsSizeOfAndDeep = nextLine(reader);
			Long sizeOf, deep;
			Vertex sourceVertex = null, targetVertex = null;
			while (classMethodsSizeOfAndDeep != null) {
				if (classMethodsSizeOfAndDeep.size() == 2) {
					previousClass = classMethodsSizeOfAndDeep.get("Class");
					previousMethod = classMethodsSizeOfAndDeep.get("Method");
					sourceVertex = generateVertex(previousClass + "." + previousMethod, 0l);
				} else {
					String nextClass = classMethodsSizeOfAndDeep.get("Class");
					String nextMethod = classMethodsSizeOfAndDeep.get("Method");
					sizeOf = Long.parseLong(classMethodsSizeOfAndDeep.get("SizeOf"));
					deep = Long.parseLong(classMethodsSizeOfAndDeep.get("Deep"));
					
					targetVertex = generateVertex(nextClass + "." + nextMethod, deep);
					//new Edge(sourceVertex, targetVertex, false, 1l, sizeOf);
					new Edge(sourceVertex, targetVertex, true, 1l, sizeOf);
					sourceVertex = graph.insert(sourceVertex);
					targetVertex = graph.insert(targetVertex);
					sourceVertex = targetVertex;
					previousClass = nextClass;
					previousMethod = nextMethod;
				}
				classMethodsSizeOfAndDeep = nextLine(reader);
			}
		} catch (FileNotFoundException e) {
			System.err.println(log + " did not find in log analyze.");
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		} catch (Exception e) {
			System.out.println("Opa!");
			e.printStackTrace();
		}
		System.out.println(">>> end analyze");
	}
	
}
