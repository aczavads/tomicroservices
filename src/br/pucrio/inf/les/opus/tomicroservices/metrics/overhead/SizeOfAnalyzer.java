package br.pucrio.inf.les.opus.tomicroservices.metrics.overhead;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

/**
 * The analyzer of the output generated by injected code in the system under analyze
 * 
 * Schema to the analyze is the following (per line): "Class:name|Method:name|SizeOf:number" (can change the order)
 * 
 * @author Luiz Carvalho <lmcarvalho@inf.puc-rio.br>
 * 
 **/
public class SizeOfAnalyzer {
		
	private Map<String, String> analyzeLine(String line) {
		String[] classMethodAndSizeOf = line.split("#");
		Map<String, String> result = new HashMap<String, String>();
		final int typeIndex = 0;
		final int valueIndex = 1;
		for (String typeAndValue: classMethodAndSizeOf) {
			String type = typeAndValue.split(":")[typeIndex];
			String value = typeAndValue.split(":")[valueIndex];
			result.put(type, value);
		}
		return result;
	}
	
	private boolean verifyValues(Map<String, String> classMethodsAndSizeOf) {
		try {
			Long.parseLong(classMethodsAndSizeOf.get("SizeOf"));
		} catch (Exception e) {
			return false;
		}
		final int elementSize = 3;
		return classMethodsAndSizeOf.containsKey("Class") && classMethodsAndSizeOf.containsKey("Method") &&
				classMethodsAndSizeOf.containsKey("SizeOf") && classMethodsAndSizeOf.size() == elementSize;
	}
	
	public Map<String, String> nextLine(BufferedReader reader) throws IOException {
		String line = reader.readLine();
		long count = 0L;
		while (line != null) {
			++count;
			Map<String, String> result = analyzeLine(line);
			if (verifyValues(result)) {
				return result;
			} else {
				System.err.println("Line out of standart: " + line + " in " + count);
			}
			line = reader.readLine();
		}
		return null;
	}
	
	public void analyzeSizeOf(File sizeOfLog, MethodGraph methodGraph) {
		try (BufferedReader reader = new BufferedReader(
				new FileReader(sizeOfLog))) {
			Map<String, String> classMethodsAndSizeOf = nextLine(reader);
			if (classMethodsAndSizeOf == null) {
				return;
			}
			String startClass = "_star_t_";
			String startMethod = "_star_t_";
			String previousClass = classMethodsAndSizeOf.get("Class");
			String previousMethod = classMethodsAndSizeOf.get("Method");
			Long sizeOf = Long.parseLong(classMethodsAndSizeOf.get("SizeOf"));
			methodGraph.insert(startClass, startMethod, previousClass, previousMethod,
					new MethodEdgeValue(sizeOf));
			classMethodsAndSizeOf = nextLine(reader);
			while (classMethodsAndSizeOf != null) {
				String nextClass = classMethodsAndSizeOf.get("Class");
				String nextMethod = classMethodsAndSizeOf.get("Method");
				sizeOf = Long.parseLong(classMethodsAndSizeOf.get("SizeOf"));
				methodGraph.insert(previousClass, previousMethod, nextClass, nextMethod, new MethodEdgeValue(sizeOf));
				previousClass = nextClass;
				previousMethod = nextMethod;
				classMethodsAndSizeOf = nextLine(reader);
			}
		} catch (FileNotFoundException e) {
			System.err.println(sizeOfLog + " did not find in sizeOf analyze.");
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		} 
	}
	
}
